#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel MAIN_1 main=MAIN_1 SINGLE_SCATTERING
#pragma kernel MAIN_N main=MAIN_N MULTIPLE_SCATTERING

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyCommon.hlsl"

#define TABLE_SIZE uint(PBRSKYCONFIG_GROUND_IRRADIANCE_TABLE_SIZE)

RW_TEXTURE2D(float4, _GroundIrradianceTable); // of TABLE_SIZE

[numthreads(64, 1, 1)]
void main(uint dispatchThreadId : SV_DispatchThreadID)
{
    // We don't care about the extremal points.
    const float scale = rcp(TABLE_SIZE);
    const float bias  = 0.5 * scale;

    // Let the hardware and the driver handle the ordering of the computation.
    uint2 tableCoord = uint2(dispatchThreadId, 0);

    float uv = tableCoord.x * scale + bias;

    // As we look at the planet in the direction of the sun, the ground is rotationally invariant.
    float NdotL = UnmapCosineOfZenithAngle(uv.x);

    float4 tableEntry = float4(0, 0, 0, 1);

#ifdef SINGLE_SCATTERING
    if (NdotL > 0)
    {
        float3 oDepth = SampleOpticalDepthTexture(NdotL, 0, false);
        float3 transm = TransmittanceFromOpticalDepth(oDepth);

        tableEntry.rgb = transm * NdotL;
    }

    _GroundIrradianceTable[tableCoord] = tableEntry; // Overwrite

#else  // MULTIPLE_SCATTERING

    // Gather the volume contribution.
    // Arbitrary number of samples...
    const int numVolumeSamples = 89;

    for (int i = 0; i < numVolumeSamples; i++)
    {
        float2 f = Fibonacci2d(i, numVolumeSamples); // TODO: Cranley-Patterson Rotation
        float2 s = SampleHemisphereCosine(f.x, f.y);

        float cosChi = s.x;
        float NdotV  = -cosChi;
        float phiL   = s.y;

        TexCoord4D tc = ConvertPositionAndOrientationToTexCoords(0, NdotV, NdotL, phiL);

        // Single scattering does not contain the phase function.
        float LdotV = SphericalDot(NdotV, 0, NdotL, phiL);

        float3 radiance = 0;

        radiance += lerp(SAMPLE_TEXTURE3D_LOD(_AirSingleScatteringTexture,     s_linear_clamp_sampler, float3(tc.u, tc.v, tc.w0), 0).rgb,
                         SAMPLE_TEXTURE3D_LOD(_AirSingleScatteringTexture,     s_linear_clamp_sampler, float3(tc.u, tc.v, tc.w1), 0).rgb,
                         tc.a) * AirPhase(LdotV);

        radiance += lerp(SAMPLE_TEXTURE3D_LOD(_AerosolSingleScatteringTexture, s_linear_clamp_sampler, float3(tc.u, tc.v, tc.w0), 0).rgb,
                         SAMPLE_TEXTURE3D_LOD(_AerosolSingleScatteringTexture, s_linear_clamp_sampler, float3(tc.u, tc.v, tc.w1), 0).rgb,
                         tc.a) * AerosolPhase(LdotV);

        float weight = PI * rcp(numVolumeSamples);

        tableEntry.rgb += weight * radiance;
    }

    _GroundIrradianceTable[tableCoord] += tableEntry; // Accumulate

#endif // MULTIPLE_SCATTERING

}
